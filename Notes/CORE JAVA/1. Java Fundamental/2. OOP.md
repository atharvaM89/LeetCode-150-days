# OOP

## **Object-Oriented Programming (OOP) Overview**

OOP (Object-Oriented Programming) is a programming paradigm that organizes software design around **objects** rather than functions or logic.

Objects represent real-world entities that contain **data (fields/variables)** and **behavior (methods)**.

---

## **Principles of OOP**

### 1.  **Abstraction**

- Hiding internal implementation details and showing only the essential features of an object.
- Example: You use a car’s steering wheel without knowing how the engine works internally.

```java
abstract class Car {
    abstract void start();
}

class Tesla extends Car {
    void start() {
        System.out.println("Tesla starts silently with electric motor.");
    }
}

```

---

### 2. **Encapsulation**

- Binding data (variables) and methods (functions) into a single unit (class).
- Data hiding is achieved by declaring variables as **private** and using **getters and setters**.

```java
public class Person {
    private String name; // private = hidden data

    public String getName() { return name; }
    public void setName(String newName) { this.name = newName; }
}

```

---

### 3. **Inheritance**

- Acquiring properties and methods of one class (superclass) into another (subclass).
- Promotes **code reusability** and logical hierarchy.

```java
class Animal {
    void eat() { System.out.println("Eating..."); }
}

class Dog extends Animal {
    void bark() { System.out.println("Barking..."); }
}

public class Test {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();   // Inherited from Animal
        d.bark();  // Dog’s own method
    }
}

```

---

### 4.  **Polymorphism**

- Means “many forms”.
- Allows methods to perform differently based on the object that is calling them.
- Achieved through:
    - **Method Overloading** (Compile-time polymorphism)
    - **Method Overriding** (Runtime polymorphism)

**Example of Overriding:**

```java
class Animal {
    void sound() { System.out.println("Animal makes sound"); }
}

class Dog extends Animal {
    void sound() { System.out.println("Dog barks"); }
}

public class Demo {
    public static void main(String[] args) {
        Animal obj = new Dog();  // Upcasting
        obj.sound();  // Output: Dog barks
    }
}

```

**Real-world analogy:**

We call all devices “TVs”, but each brand (Sony, LG, Samsung) behaves differently — that’s **Polymorphism**.

---

## **Advantages of OOP**

- Faster and easier to execute.
- Provides a clear structure for programs.
- Promotes **DRY (Don’t Repeat Yourself)** principle.
- Easier to maintain, modify, and debug.
- Encourages code reusability through inheritance.
- Enables development of large-scale, modular applications.

---

## **Class and Object**

### Class

- A **template** or **blueprint** for creating objects.
- Defines properties (variables) and behaviors (methods).

### Object

- An **instance** of a class.
- When an object is created, it inherits all variables and methods from the class.

**Example:**

```java
class Fruit {
    String name;
    void display() {
        System.out.println("Fruit: " + name);
    }
}

public class Main {
    public static void main(String[] args) {
        Fruit f1 = new Fruit();
        f1.name = "Mango";
        f1.display();
    }
}

```

---

## **Creating a Class and Object**

```java
public class Main {
  int x = 5;

  public static void main(String[] args) {
    Main myObj = new Main();
    System.out.println(myObj.x);
  }
}

```

---

## **Using Multiple Classes**

```java
public class Main {
  int x = 5;
}

class Second {
  public static void main(String[] args) {
    Main myObj = new Main();
    System.out.println(myObj.x);
  }
}

```

*(File name should match the class that contains `main()` method.)*

---

## **Class Attributes (Variables)**

```java
public class Main {
  int x = 10;

  public static void main(String[] args) {
    Main myObj = new Main();
    myObj.x = 25;
    System.out.println(myObj.x);
  }
}

```

### Multiple Attributes Example

```java
public class Main {
  String fname = "John";
  String lname = "Doe";
  int age = 24;

  public static void main(String[] args) {
    Main myObj = new Main();
    System.out.println("Name: " + myObj.fname + " " + myObj.lname);
    System.out.println("Age: " + myObj.age);
  }
}

```

---

## **Class Methods**

### Static vs Public Methods

| Method Type | Description | Example |
| --- | --- | --- |
| **Static** | Can be called without creating object | `Main.myStaticMethod();` |
| **Public** | Must be called using an object | `obj.myPublicMethod();` |

```java
public class Main {
  static void myStaticMethod() {
    System.out.println("Static method called");
  }

  public void myPublicMethod() {
    System.out.println("Public method called");
  }

  public static void main(String[] args) {
    myStaticMethod(); // no object needed
    Main obj = new Main();
    obj.myPublicMethod(); // object required
  }
}

```

---

## **Data Hiding**

- Achieved using `private` keyword.
- Data can only be accessed through getter and setter methods.

---

## **Methods**

- A **block of code** that runs when called.
- Can accept **parameters** and **return values**.

```java
public class Test {
    static int max(int x, int y) {
        if(x > y)
            return x;
        else
            return y;
    }

    public static void main(String[] args) {
        int a = 10, b = 15;
        int c = max(a, b);
        System.out.println("Maximum: " + c);
    }
}

```

---

## **Method Parameters**

- **Formal parameters:** defined in method definition
- **Actual parameters:** values passed during method call
    
    (Names can differ but order and type must match.)
    

---

## **Method Overloading**

- Same method name, different parameters or types.
- Increases readability and reusability.

```java
int add(int a, int b) { return a + b; }
double add(double a, double b) { return a + b; }
String add(String a, String b) { return a + b; }

```

---

## **Java Recursion**

When a method calls itself repeatedly.

```java
public class Recursion {
  static int sum(int n) {
    if (n == 0) return 0;
    return n + sum(n - 1);
  }

  public static void main(String[] args) {
    System.out.println(sum(5)); // Output: 15
  }
}

```

---

## **Constructors**

- Used to initialize objects.
- Automatically called when an object is created.
- **Name must match class name.**
- **No return type.**

### 1. Non-Parameterized Constructor

```java
public class Main {
  int x;
  public Main() {
    x = 5;
  }
}

```

### 2. Parameterized Constructor

```java
public class Main {
  int modelYear;
  String modelName;

  public Main(int year, String name) {
    modelYear = year;
    modelName = name;
  }

  public static void main(String[] args) {
    Main car = new Main(1969, "Mustang");
    System.out.println(car.modelYear + " " + car.modelName);
  }
}

```

---

## **Modifiers**

### 1. **Access Modifiers**

Control where classes and members are accessible.

| Type | For Classes | For Variables/Methods |
| --- | --- | --- |
| public | Accessible everywhere | Accessible everywhere |
| private | ❌ Not allowed | Accessible only within class |
| protected | ❌ Not allowed | Accessible within same package and subclasses |
| default | Within same package | Within same package |

---

### 2. **Non-Access Modifiers**

| Modifier | Used For | Description |
| --- | --- | --- |
| `final` | class, method, variable | Prevent inheritance or modification |
| `static` | method, variable | Belongs to class, not object |
| `abstract` | class, method | Must be overridden in subclass |
| `transient` | variable | Skips during serialization |
| `volatile` | variable | Value may change unexpectedly |
| `synchronized` | method/block | Thread-safe access |

---

## **Encapsulation Example**

```java
public class Student {
  private int rollNo;
  private String name;

  public int getRollNo() { return rollNo; }
  public void setRollNo(int rollNo) { this.rollNo = rollNo; }

  public String getName() { return name; }
  public void setName(String name) { this.name = name; }
}

```

---

## **Inheritance Types**

1. **Single Inheritance**
    
    → One parent, one child
    
2. **Multilevel Inheritance**
    
    → Parent → Child → Grandchild
    
3. **Hierarchical Inheritance**
    
    → One parent, multiple children
    
4. **Multiple Inheritance**
    
    → Not directly supported in Java (handled using **interfaces**)
    

---

## **Abstraction in Java**

Hiding complex implementation and showing only essential details.

### 1. Abstract Class

```java
abstract class Shape {
  abstract void draw();
}

class Circle extends Shape {
  void draw() { System.out.println("Drawing Circle"); }
}

```

### 2. Interface

```java
interface Animal {
  void sound();
}

class Cat implements Animal {
  public void sound() {
    System.out.println("Meow");
  }
}

```

---

## **Polymorphism in Depth**

### Compile-Time (Method Overloading)

Determined at compile time.

### Runtime (Method Overriding)

Determined at runtime (Dynamic Binding).

---

## **Super Keyword**

Used to access parent class members.

```java
class Animal {
  void eat() { System.out.println("Eating"); }
}

class Dog extends Animal {
  void eat() {
    super.eat(); // Calls parent method
    System.out.println("Eating bones");
  }
}

```

---

## **this Keyword**

Refers to the current object.

```java
class Student {
  int id;
  String name;

  Student(int id, String name) {
    this.id = id;
    this.name = name;
  }
}

```

---

## **Final Keyword**

- **final variable** → value cannot change
- **final method** → cannot be overridden
- **final class** → cannot be inherited

---

## **Constructors and Inheritance**

- When a subclass object is created, the **superclass constructor** is automatically called first.

```java
class A {
  A() { System.out.println("A Constructor"); }
}

class B extends A {
  B() { System.out.println("B Constructor"); }
}

```

Output:

```
A Constructor
B Constructor

```

---

## **Summary of OOP Concepts**

| Concept | Description | Example Keyword |
| --- | --- | --- |
| Abstraction | Hiding implementation details | `abstract`, `interface` |
| Encapsulation | Binding data & methods | `private`, getters/setters |
| Inheritance | Reuse properties & methods | `extends` |
| Polymorphism | Same method, different behavior | `overloading`, `overriding` |